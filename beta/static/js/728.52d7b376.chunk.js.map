{"version":3,"file":"static/js/728.52d7b376.chunk.js","mappings":"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","sources":["components/map/components/WDTrigger.tsx","components/map/components/WDCenter.tsx","components/map/components/WDLabel.tsx","utils/map/getUnits.ts","components/map/components/WDProvince.tsx","components/map/components/WDUnitSlot.tsx","components/map/components/WDProvinceOverlay.tsx","enums/ArrowType.ts","components/map/variants/classic/components/WDBoardMap.tsx","enums/BuildUnit.ts","utils/map/WDArrowMarkerDefs.tsx","data/BuildUnit.ts","components/map/components/WDBuildUnitButtons.tsx","components/map/components/WDBuildContainer.tsx","components/map/components/WDFlyoutButton.tsx","components/map/components/WDFlyoutContainer.tsx","utils/map/drawArrowFunctional.tsx","utils/map/arrowDispatchReceiveCoordinates.ts","components/map/components/WDArrowContainer.tsx","components/map/WDMap.tsx","components/controllers/WDMapController.tsx","utils/map/getInitialViewTranslation.ts"],"sourcesContent":["import * as React from \"react\";\n\nconst WDTrigger: React.FC = function (): React.ReactElement {\n  return (\n    <rect\n      className=\"trigger\"\n      height=\"100%\"\n      width=\"100%\"\n      fill=\"black\"\n      style={{ opacity: 0 }}\n    />\n  );\n};\n\nexport default WDTrigger;\n","import { useTheme } from \"@mui/material\";\nimport * as React from \"react\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport { Coordinates } from \"../../../interfaces\";\nimport WDTrigger from \"./WDTrigger\";\n\ninterface WDCenterProps extends Coordinates {\n  province: Province;\n}\n\nconst WDCenter: React.FC<WDCenterProps> = function ({\n  province,\n  x,\n  y,\n}): React.ReactElement {\n  const theme = useTheme();\n  return (\n    <svg\n      id={`${province}-center`}\n      width=\"34\"\n      height=\"34\"\n      viewBox=\"0 0 34 34\"\n      fill=\"none\"\n      x={x}\n      y={y}\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path\n        d=\"M17 32.9998C25.8366 32.9998 33 25.8364 33 16.9999C33 8.1634 25.8366 1 17 1C8.16344 1 1 8.1634 1 16.9999C1 25.8364 8.16344 32.9998 17 32.9998Z\"\n        stroke={theme.palette.primary.main}\n      />\n      <path\n        d=\"M17.0064 25.7269C21.8263 25.7269 25.7336 21.8196 25.7336 16.9997C25.7336 12.1797 21.8263 8.27243 17.0064 8.27243C12.1866 8.27243 8.2793 12.1797 8.2793 16.9997C8.2793 21.8196 12.1866 25.7269 17.0064 25.7269Z\"\n        fill={theme.palette.primary.main}\n      />\n      <WDTrigger />\n    </svg>\n  );\n};\n\nexport default WDCenter;\n","import { useTheme } from \"@mui/material\";\nimport * as React from \"react\";\nimport { Label } from \"../../../interfaces\";\n\ninterface WDLabelProps extends Label {\n  id?: string;\n}\n\nconst WDLabel: React.FC<WDLabelProps> = function ({\n  id,\n  style,\n  text,\n  x,\n  y,\n}): React.ReactElement {\n  const theme = useTheme();\n  return (\n    <text\n      key={id}\n      className=\"label\"\n      style={{\n        fill: theme.palette.primary.main,\n        fontWeight: 900,\n        fontSize: \"150%\",\n        userSelect: \"none\",\n        ...style,\n      }}\n      x={x}\n      y={y}\n      id={id}\n    >\n      {text}\n    </text>\n  );\n};\n\nWDLabel.defaultProps = {\n  id: undefined,\n};\n\nexport default WDLabel;\n","import GameDataResponse, {\n  APITerritories,\n} from \"../../state/interfaces/GameDataResponse\";\nimport GameOverviewResponse from \"../../state/interfaces/GameOverviewResponse\";\nimport TerritoryMap, {\n  MTerritory,\n  webdipNameToTerritory,\n} from \"../../data/map/variants/classic/TerritoryMap\";\nimport countryMap from \"../../data/map/variants/classic/CountryMap\";\nimport Country from \"../../enums/Country\";\nimport {\n  IOrderData,\n  IOrderDataHistorical,\n  IProvinceStatus,\n  IUnit,\n  IUnitHistorical,\n} from \"../../models/Interfaces\";\nimport UIState from \"../../enums/UIState\";\nimport OrdersMeta, { OrderMeta } from \"../../state/interfaces/SavedOrders\";\nimport { MemberData } from \"../../interfaces/state/MemberData\";\nimport getAvailableOrder from \"../state/getAvailableOrder\";\nimport GameStateMaps from \"../../state/interfaces/GameStateMaps\";\n\nexport enum UnitDrawMode {\n  NONE = \"none\",\n  HOLD = \"hold\",\n  DISBANDED = \"disbanded\",\n  DISLODGED = \"dislodged\",\n  DISLODGING = \"dislodging\",\n  BUILD = \"build\",\n}\n\n// What we manually construct to unify historical and live units and\n// pass down to deeper state for rendering the UI\nexport interface Unit {\n  country: Country;\n  mappedTerritory: MTerritory;\n  unit: IUnit;\n  drawMode: UnitDrawMode;\n  movedFromTerrID: string | null;\n}\n\nexport function getUnitsLive(\n  territories: APITerritories,\n  territoryStatuses: IProvinceStatus[],\n  units: { [key: string]: IUnit },\n  members: GameOverviewResponse[\"members\"],\n  prevPhaseOrders: IOrderDataHistorical[],\n  ordersMeta: OrdersMeta,\n  currentOrders: IOrderData[],\n  currentUser: { member: MemberData },\n  phase: string,\n  maps: GameStateMaps,\n): Unit[] {\n  // Accumulate all the units we want to draw into here\n  const unitsToDraw: Unit[] = [];\n\n  //--------------------------------------------------------------------\n  // Precompute a bunch of useful mappings\n  //--------------------------------------------------------------------\n\n  const territoryStatusesByProvID = Object.fromEntries(\n    territoryStatuses.map((territoryStatus) => [\n      territoryStatus.id,\n      territoryStatus,\n    ]),\n  );\n  const unitCountByProvID: { [key: string]: number } = {};\n  Object.values(units).forEach((unit) => {\n    const provID = maps.terrIDToProvinceID[unit.terrID];\n    if (provID in unitCountByProvID) {\n      unitCountByProvID[provID] += 1;\n    } else {\n      unitCountByProvID[provID] = 1;\n    }\n  });\n\n  // Maps current terrID => previous terrID for units that successfully moved last phase.\n  const successfulPrevMoves: { [key: string]: string } = {};\n  prevPhaseOrders.forEach((prevOrder) => {\n    if (prevOrder.success && prevOrder.type === \"Move\") {\n      successfulPrevMoves[prevOrder.toTerrID.toString()] =\n        prevOrder.terrID.toString();\n    }\n  });\n\n  const ordersMetaByTerrID: { [key: string]: OrderMeta } = {};\n  Object.entries(ordersMeta).forEach(([orderID, orderMeta]) => {\n    // FIXME having to chain lookups like this here and in many other places in the\n    // code is horrible. Maybe we can improve this by just making things like OrdersMeta\n    // have *all* of the data on them, rather than just a subset.\n    // Or making the webdip API be more helpful and add more convenience fields to stuff.\n    const currentOrder = currentOrders.find((order) => order.id === orderID);\n    // console.log({ orderID, orderMeta, currentOrder, units });\n\n    if (currentOrder) {\n      // for normal orders it's the first case, for builds/destroys the second\n      const terrID =\n        units[currentOrder.unitID]?.terrID || orderMeta.update?.toTerrID;\n      if (terrID) {\n        ordersMetaByTerrID[terrID] = orderMeta;\n      }\n    }\n  });\n\n  const excessUnitsBeyondSCs =\n    currentUser.member.unitNo - currentUser.member.supplyCenterNo;\n  const isDestroyPhase = phase === \"Builds\" && excessUnitsBeyondSCs > 0;\n  const allDestroysAssigned =\n    !isDestroyPhase || !getAvailableOrder(currentOrders, ordersMeta);\n\n  // console.log({ prevPhaseOrders });\n  // console.log({ successfulMoves });\n  // console.log({ ordersMetaByTerrID });\n  //--------------------------------------------------------------------\n  // Compute the units to draw from the current units\n  //--------------------------------------------------------------------\n  Object.values(units).forEach((unit) => {\n    const territory = territories[unit.terrID];\n    if (territory) {\n      const mappedTerritory =\n        TerritoryMap[webdipNameToTerritory[territory.name]];\n      if (mappedTerritory) {\n        const memberCountry = members.find(\n          (member) => member.countryID.toString() === unit.countryID,\n        );\n        if (memberCountry) {\n          const { country } = memberCountry;\n\n          const unitProvID = maps.terrIDToProvinceID[unit.terrID];\n          let drawMode = UnitDrawMode.NONE;\n          const isRetreat =\n            territoryStatusesByProvID[unitProvID] &&\n            territoryStatusesByProvID[unitProvID].unitID !== null &&\n            territoryStatusesByProvID[unitProvID].unitID !== unit.id;\n\n          if (ordersMetaByTerrID[unit.terrID]?.update?.type === \"Hold\") {\n            drawMode = UnitDrawMode.HOLD;\n          } else if (\n            isRetreat &&\n            // Webdip API might specify disbands in terms of province ID.\n            // So also check the province ID, i.e. the ID of the root territory.\n            (ordersMetaByTerrID[unit.terrID]?.update?.type === \"Disband\" ||\n              ordersMetaByTerrID[unitProvID]?.update?.type === \"Disband\")\n          ) {\n            drawMode = UnitDrawMode.DISBANDED;\n          } else if (\n            // Webdip API specifies destroys in terms of province ID!!\n            // So also check the province ID, i.e. the ID of the root territory.\n            ordersMetaByTerrID[unit.terrID]?.update?.type === \"Destroy\" ||\n            ordersMetaByTerrID[unitProvID]?.update?.type === \"Destroy\"\n          ) {\n            drawMode = UnitDrawMode.DISBANDED;\n          } else if (isRetreat) {\n            drawMode = UnitDrawMode.DISLODGED;\n          } else if (unitCountByProvID[unitProvID] >= 2) {\n            drawMode = UnitDrawMode.DISLODGING;\n          } else if (\n            unit.countryID === currentUser.member.countryID.toString() &&\n            isDestroyPhase &&\n            !allDestroysAssigned\n          ) {\n            // while the user hasn't inputted enough destroy orders,\n            // mark all units according to the little red striping for dislodged\n            drawMode = UnitDrawMode.DISLODGED;\n          }\n\n          const movedFromTerrID =\n            unit.terrID in successfulPrevMoves\n              ? successfulPrevMoves[unit.terrID]\n              : null;\n\n          unitsToDraw.push({\n            country: countryMap[country],\n            mappedTerritory,\n            unit,\n            drawMode,\n            movedFromTerrID,\n          });\n        }\n      }\n    }\n  });\n\n  //--------------------------------------------------------------------\n  // Compute all the additional units to draw from the current orders\n  // Namely, the builds.\n  //--------------------------------------------------------------------\n  Object.entries(ordersMeta).forEach(([orderID, { update }], index) => {\n    if (\n      !update ||\n      !update.type ||\n      !update.type.startsWith(\"Build \") ||\n      update.toTerrID === null\n    ) {\n      return;\n    }\n    // FIXME hack to handle the fact that right now ordersmeta is not\n    // cleaned out between phases, we have to make sure that the order\n    // actually exists\n    const currentOrder = currentOrders.find((order) => order.id === orderID);\n    if (!currentOrder) {\n      return;\n    }\n\n    const territory = territories[update.toTerrID];\n    const iUnit: IUnit = {\n      // Arbitrarily add 100000 to get unique ids from the normal units\n      id: (index + 100000).toString(),\n      countryID: territory.countryID,\n      type: update.type.split(\" \")[1] as unknown as string, // Build Army --> Army\n      terrID: update.toTerrID,\n    };\n    if (territory) {\n      const mappedTerritory =\n        TerritoryMap[webdipNameToTerritory[territory.name]];\n      if (mappedTerritory) {\n        const memberCountry = members.find(\n          (member) => member.countryID.toString() === iUnit.countryID,\n        );\n        if (memberCountry) {\n          const { country } = memberCountry;\n          unitsToDraw.push({\n            country: countryMap[country],\n            mappedTerritory,\n            unit: iUnit,\n            drawMode: UnitDrawMode.BUILD,\n            movedFromTerrID: null,\n          });\n        }\n      }\n    }\n  });\n\n  return unitsToDraw;\n}\n\nexport function getUnitsHistorical(\n  territories: APITerritories,\n  units: IUnitHistorical[],\n  members: GameOverviewResponse[\"members\"],\n  prevPhaseOrders: IOrderDataHistorical[],\n  curPhaseOrders: IOrderDataHistorical[],\n  maps: GameStateMaps,\n): Unit[] {\n  // Accumulate all the units we want to draw into here\n  const unitsToDraw: Unit[] = [];\n\n  //--------------------------------------------------------------------\n  // Precompute a bunch of useful mappings\n  //--------------------------------------------------------------------\n\n  const unitCountByTerrID: { [key: string]: number } = {};\n  units.forEach((unit) => {\n    if (unit.terrID in unitCountByTerrID) {\n      unitCountByTerrID[unit.terrID] += 1;\n    } else {\n      unitCountByTerrID[unit.terrID] = 1;\n    }\n  });\n\n  // Maps current terrID => previous terrID for units that successfully moved last phase.\n  const successfulPrevMoves: { [key: string]: string } = {};\n  prevPhaseOrders.forEach((prevOrder) => {\n    if (prevOrder.success && prevOrder.type === \"Move\") {\n      successfulPrevMoves[prevOrder.toTerrID.toString()] =\n        prevOrder.terrID.toString();\n    }\n  });\n\n  const curPhaseOrdersByTerrID: { [key: string]: IOrderDataHistorical } = {};\n  curPhaseOrders.forEach((order) => {\n    curPhaseOrdersByTerrID[order.terrID] = order;\n  });\n\n  //--------------------------------------------------------------------\n  // Compute the units to draw from the historical units\n  //--------------------------------------------------------------------\n  units.forEach((unit, index) => {\n    const territory = territories[unit.terrID];\n    const iUnit = {\n      id: index.toString(),\n      countryID: unit.countryID.toString(),\n      type: unit.unitType,\n      terrID: unit.terrID.toString(),\n    };\n\n    if (territory) {\n      const mappedTerritory =\n        TerritoryMap[webdipNameToTerritory[territory.name]];\n      if (mappedTerritory) {\n        const memberCountry = members.find(\n          (member) => member.countryID.toString() === iUnit.countryID,\n        );\n        if (memberCountry) {\n          const { country } = memberCountry;\n\n          const unitProvID = maps.terrIDToProvinceID[unit.terrID];\n\n          let drawMode = UnitDrawMode.NONE;\n          if (curPhaseOrdersByTerrID[unit.terrID]?.type === \"Hold\") {\n            drawMode = UnitDrawMode.HOLD;\n          } else if (\n            unit.retreating === \"Yes\" &&\n            // Webdip API might specify disbands in terms of province ID.\n            // So also check the province ID, i.e. the ID of the root territory.\n            (curPhaseOrdersByTerrID[unit.terrID]?.type === \"Disband\" ||\n              curPhaseOrdersByTerrID[unitProvID]?.type === \"Disband\")\n          ) {\n            drawMode = UnitDrawMode.DISBANDED;\n          } else if (\n            // Webdip API specifies destroys in terms of province ID!!\n            // So also check the province ID, i.e. the ID of the root territory.\n            curPhaseOrdersByTerrID[unit.terrID]?.type === \"Destroy\" ||\n            curPhaseOrdersByTerrID[unitProvID]?.type === \"Destroy\"\n          ) {\n            drawMode = UnitDrawMode.DISBANDED;\n          } else if (unit.retreating === \"Yes\") {\n            drawMode = UnitDrawMode.DISLODGED;\n          } else if (unitCountByTerrID[unit.terrID] >= 2) {\n            drawMode = UnitDrawMode.DISLODGING;\n          }\n\n          const movedFromTerrID =\n            unit.terrID in successfulPrevMoves\n              ? successfulPrevMoves[unit.terrID]\n              : null;\n\n          unitsToDraw.push({\n            country: countryMap[country],\n            mappedTerritory,\n            unit: iUnit,\n            drawMode,\n            movedFromTerrID,\n          });\n        }\n      }\n    }\n  });\n\n  //--------------------------------------------------------------------\n  // Compute all the units additional to draw from the historical orders\n  //--------------------------------------------------------------------\n  curPhaseOrders.forEach((order, index) => {\n    if (!order.type.startsWith(\"Build \")) {\n      return;\n    }\n    const territory = territories[order.terrID];\n    const iUnit: IUnit = {\n      // Arbitrarily add 100000 to get unique ids from the normal units\n      id: (index + 100000).toString(),\n      countryID: order.countryID.toString(),\n      type: order.type.split(\" \")[1] as unknown as string, // Build Army --> Army\n      terrID: order.terrID.toString(),\n    };\n    if (territory) {\n      const mappedTerritory =\n        TerritoryMap[webdipNameToTerritory[territory.name]];\n      if (mappedTerritory) {\n        const memberCountry = members.find(\n          (member) => member.countryID.toString() === iUnit.countryID,\n        );\n        if (memberCountry) {\n          const { country } = memberCountry;\n          unitsToDraw.push({\n            country: countryMap[country],\n            mappedTerritory,\n            unit: iUnit,\n            drawMode: UnitDrawMode.BUILD,\n            movedFromTerrID: null,\n          });\n        }\n      }\n    }\n  });\n\n  return unitsToDraw;\n}\n","import { useTheme } from \"@mui/material\";\nimport * as React from \"react\";\nimport countryMap from \"../../../data/map/variants/classic/CountryMap\";\nimport { ProvinceMapData } from \"../../../interfaces\";\nimport {\n  gameApiSliceActions,\n  gameMaps,\n  gameOverview,\n} from \"../../../state/game/game-api-slice\";\nimport { useAppDispatch, useAppSelector } from \"../../../state/hooks\";\nimport ClickObjectType from \"../../../types/state/ClickObjectType\";\nimport WDCenter from \"./WDCenter\";\nimport WDLabel from \"./WDLabel\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport Territory from \"../../../enums/map/variants/classic/Territory\";\n\ninterface WDProvinceProps {\n  provinceMapData: ProvinceMapData;\n  ownerCountryID: string | undefined;\n  playerCountryID: number | undefined;\n  highlightSelection: boolean;\n}\n\nconst WDProvince: React.FC<WDProvinceProps> = function ({\n  provinceMapData,\n  ownerCountryID,\n  playerCountryID,\n  highlightSelection,\n}): React.ReactElement {\n  const theme = useTheme();\n  const dispatch = useAppDispatch();\n\n  const { user, members } = useAppSelector(gameOverview);\n\n  const { province } = provinceMapData;\n  let territoryFill = \"none\";\n  let territoryFillOpacity = 0;\n  const territoryStrokeOpacity = 1;\n\n  // Normally, color according to supply center ownership\n  if (ownerCountryID) {\n    const ownerCountry = members.find(\n      (m) => m.countryID === Number(ownerCountryID),\n    )?.country;\n    if (ownerCountry && provinceMapData.type !== \"Sea\") {\n      territoryFill = theme.palette[ownerCountry]?.main;\n      territoryFillOpacity = 0.4;\n    }\n  }\n\n  // If highlighting a selection, color according to the active player's\n  // color, and more opaque.\n  if (highlightSelection && playerCountryID) {\n    const playerCountry = members.find(\n      (m) => m.countryID === playerCountryID,\n    )?.country;\n    if (playerCountry) {\n      territoryFill = theme.palette[playerCountry]?.main;\n      territoryFillOpacity = 1.0;\n    }\n  }\n\n  const clickAction = function (\n    evt: React.MouseEvent<SVGGElement, MouseEvent>,\n  ) {\n    dispatch(\n      gameApiSliceActions.processMapClick({\n        evt,\n        clickProvince: province,\n      }),\n    );\n  };\n  return (\n    <svg\n      height={provinceMapData.height}\n      id={`${province}-province`}\n      viewBox={provinceMapData.viewBox}\n      width={provinceMapData.width}\n      x={provinceMapData.x}\n      y={provinceMapData.y}\n    >\n      <g onClick={(e) => clickAction(e)}>\n        {provinceMapData.texture?.texture && (\n          <path\n            d={provinceMapData.path}\n            fill={provinceMapData.texture.texture}\n            id={`${province}-texture`}\n            stroke={provinceMapData.texture.stroke}\n            strokeOpacity={provinceMapData.texture.strokeOpacity}\n            strokeWidth={provinceMapData.texture.strokeWidth}\n          />\n        )}\n        <path\n          d={provinceMapData.path}\n          fill={territoryFill}\n          fillOpacity={territoryFillOpacity}\n          id={`${province}-control-path`}\n          stroke={theme.palette.primary.main}\n          strokeOpacity={1}\n          strokeWidth={territoryStrokeOpacity}\n        />\n      </g>\n      {provinceMapData.centerPos && (\n        <g className=\"no-pointer-events\">\n          <WDCenter\n            province={province}\n            x={provinceMapData.centerPos.x}\n            y={provinceMapData.centerPos.y}\n          />\n        </g>\n      )}\n      {provinceMapData.labels &&\n        provinceMapData.labels.map(({ name, text, style, x, y }, i) => {\n          let txt = text;\n          const id = `${province}-label-${name}`;\n          if (!txt) {\n            txt = provinceMapData.abbr;\n          }\n          return (\n            <g key={id} className=\"no-pointer-events\">\n              <WDLabel\n                id={id}\n                name={name}\n                key={id || i}\n                style={style}\n                text={txt}\n                x={x}\n                y={y}\n              />\n            </g>\n          );\n        })}\n    </svg>\n  );\n};\n\nexport default WDProvince;\n","import * as React from \"react\";\nimport Territory from \"../../../enums/map/variants/classic/Territory\";\nimport { Coordinates } from \"../../../interfaces\";\n\ninterface WDUnitSlotProps extends Coordinates {\n  name: string;\n}\n\nconst WDUnitSlot: React.FC<WDUnitSlotProps> = function ({\n  children,\n  name,\n  x,\n  y,\n}): React.ReactElement {\n  return (\n    <svg\n      className=\"unit-slot\"\n      id={`${name}-unit-slot`}\n      style={{ overflow: \"visible\" }}\n      x={x}\n      y={y}\n    >\n      {children}\n    </svg>\n  );\n};\n\nexport default WDUnitSlot;\n","import { useTheme } from \"@mui/material\";\nimport * as React from \"react\";\nimport UIState from \"../../../enums/UIState\";\nimport { Coordinates, ProvinceMapData } from \"../../../interfaces\";\nimport OrderType from \"../../../types/state/OrderType\";\nimport UnitType from \"../../../types/UnitType\";\nimport WDUnit from \"../../ui/units/WDUnit\";\nimport WDUnitSlot from \"./WDUnitSlot\";\nimport { Unit, UnitDrawMode } from \"../../../utils/map/getUnits\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport Territory from \"../../../enums/map/variants/classic/Territory\";\nimport { IProvinceStatus } from \"../../../models/Interfaces\";\n\ninterface WDProvinceOverlayProps {\n  provinceMapData: ProvinceMapData;\n  units: Unit[];\n  highlightChoice: boolean;\n}\n\nconst WDProvinceOverlay: React.FC<WDProvinceOverlayProps> = function ({\n  provinceMapData,\n  units,\n  highlightChoice,\n}): React.ReactElement {\n  const { province } = provinceMapData;\n\n  // Maps unitSlot name -> unit to draw.\n  const unitFCs: { [key: string]: React.ReactElement } = {};\n  // Maps unitSlot name -> unit to draw, but specifically for units\n  // that are currently disloging another unit on a retreat phase.\n  // This is separate because we need to draw the\n  // dislodger unit in an alternative location when there are two\n  // units in a territory so that they don't overlap each other, including\n  // when those units share the same unitSlot within that territory.\n  const unitFCsDislodging: { [key: string]: React.ReactElement } = {};\n\n  units\n    .filter((unit) => unit.mappedTerritory.province === province)\n    .forEach((unit) => {\n      let unitState: UIState;\n      switch (unit.drawMode) {\n        case UnitDrawMode.NONE:\n          unitState = UIState.NONE;\n          break;\n        case UnitDrawMode.HOLD:\n          unitState = UIState.HOLD;\n          break;\n        case UnitDrawMode.BUILD:\n          // This state of drawing the unit reduces constrast on the unit and isn't necessary\n          // now that we have green build circles highlighting the new builds.\n          // unitState = UIState.BUILD;\n          unitState = UIState.NONE;\n          break;\n        case UnitDrawMode.DISLODGING:\n          unitState = UIState.NONE;\n          break;\n        case UnitDrawMode.DISLODGED:\n          unitState = UIState.DISLODGED;\n          break;\n        case UnitDrawMode.DISBANDED:\n          unitState = UIState.DISBANDED;\n          break;\n        default:\n          unitState = UIState.NONE;\n          break;\n      }\n      const wdUnit = (\n        <WDUnit\n          id={`${province}-unit`}\n          country={unit.country}\n          meta={unit}\n          type={unit.unit.type as UnitType}\n          iconState={unitState}\n        />\n      );\n      if (unit.drawMode === UnitDrawMode.DISLODGING) {\n        unitFCsDislodging[unit.mappedTerritory.unitSlotName] = wdUnit;\n      } else {\n        unitFCs[unit.mappedTerritory.unitSlotName] = wdUnit;\n      }\n    });\n\n  return (\n    <svg\n      height={provinceMapData.height}\n      id={`${province}-province-overlay`}\n      viewBox={provinceMapData.viewBox}\n      width={provinceMapData.width}\n      x={provinceMapData.x}\n      y={provinceMapData.y}\n      overflow=\"visible\"\n    >\n      {highlightChoice && (\n        <path\n          d={provinceMapData.path}\n          fill=\"none\"\n          fillOpacity={0.0}\n          id={`${province}-choice-outline`}\n          stroke=\"black\"\n          strokeOpacity={1}\n          strokeWidth={5}\n        />\n      )}\n      {provinceMapData.unitSlots\n        .filter(({ name }) => name in unitFCs)\n        .map(({ name, x, y }) => (\n          <WDUnitSlot key={name} name={name} x={x} y={y}>\n            {unitFCs[name]}\n          </WDUnitSlot>\n        ))}\n      {provinceMapData.unitSlots\n        .filter(({ name }) => name in unitFCsDislodging)\n        .map(({ name, arrowReceiver }) => {\n          const unitName = `${name}-dislodging`;\n          // For dislodger units, we draw them at the location of the\n          // arrow receiver.\n          return (\n            <WDUnitSlot\n              key={unitName}\n              name={unitName}\n              x={arrowReceiver.x}\n              y={arrowReceiver.y}\n            >\n              {unitFCsDislodging[name]}\n            </WDUnitSlot>\n          );\n        })}\n    </svg>\n  );\n};\n\nexport default WDProvinceOverlay;\n","enum ArrowType {\n  CONVOY,\n  MOVE,\n  SUPPORT,\n  HOLD,\n}\n\nexport default ArrowType;\n","import * as React from \"react\";\nimport WDProvince from \"../../../components/WDProvince\";\nimport WDProvinceOverlay from \"../../../components/WDProvinceOverlay\";\nimport { Unit } from \"../../../../../utils/map/getUnits\";\nimport provincesMapData from \"../../../../../data/map/ProvincesMapData\";\nimport Province from \"../../../../../enums/map/variants/classic/Province\";\nimport {\n  gameData,\n  gameLegalOrders,\n  gameMaps,\n  gameOrder,\n  gameOverview,\n} from \"../../../../../state/game/game-api-slice\";\nimport { useAppSelector } from \"../../../../../state/hooks\";\nimport { IProvinceStatus } from \"../../../../../models/Interfaces\";\nimport OrderState from \"../../../../../state/interfaces/OrderState\";\nimport { LegalOrders } from \"../../../../../utils/state/gameApiSlice/extraReducers/fetchGameData/precomputeLegalOrders\";\nimport TerritoryMap from \"../../../../../data/map/variants/classic/TerritoryMap\";\nimport countryMap from \"../../../../../data/map/variants/classic/CountryMap\";\n\ninterface WDBoardMapProps {\n  units: Unit[];\n  centersByProvince: { [key: string]: { ownerCountryID: string } };\n  phase: string;\n  isLatestPhase: boolean;\n}\n\nconst WDBoardMap: React.FC<WDBoardMapProps> = function ({\n  units,\n  centersByProvince,\n  phase,\n  isLatestPhase,\n}): React.ReactElement {\n  const gameDataResponse = useAppSelector(gameData);\n  const maps = useAppSelector(gameMaps);\n  const provinceStatusByProvID: { [key: string]: IProvinceStatus } = {};\n  gameDataResponse.data.territoryStatuses.forEach((provinceStatus) => {\n    provinceStatusByProvID[maps.terrIDToProvince[provinceStatus.id]] =\n      provinceStatus;\n  });\n\n  const curOrder: OrderState = useAppSelector(gameOrder);\n  const legalOrders: LegalOrders = useAppSelector(gameLegalOrders);\n\n  const overview = useAppSelector(gameOverview);\n  const { members, user } = overview;\n\n  let provincesToHighlight: Province[] = [];\n  let provincesToChoose: Province[] = [];\n  if (isLatestPhase && user) {\n    if (phase === \"Diplomacy\") {\n      if (!curOrder.inProgress) {\n        provincesToHighlight = [];\n        provincesToChoose = [];\n      } else if (curOrder.type === \"Move\") {\n        if (curOrder.viaConvoy) {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n          ];\n          provincesToChoose = legalOrders.legalViasByUnitID[\n            curOrder.unitID\n          ].map((via) => TerritoryMap[via.dest].province);\n        } else {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n          ];\n          provincesToChoose = legalOrders.legalMoveDestsByUnitID[\n            curOrder.unitID\n          ].map((territory) => TerritoryMap[territory].province);\n        }\n      } else if (curOrder.type === \"Support\") {\n        if (curOrder.fromTerrID) {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n            maps.terrIDToProvince[curOrder.fromTerrID],\n          ];\n          provincesToChoose = legalOrders.legalSupportsByUnitID[\n            curOrder.unitID\n          ][maps.terrIDToProvince[curOrder.fromTerrID]].map(\n            (support) => support.dest,\n          );\n        } else {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n          ];\n          provincesToChoose = Object.keys(\n            legalOrders.legalSupportsByUnitID[curOrder.unitID],\n          ) as Province[];\n        }\n      } else if (curOrder.type === \"Convoy\") {\n        if (curOrder.fromTerrID) {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n            maps.terrIDToProvince[curOrder.fromTerrID],\n          ];\n          provincesToChoose = Object.keys(\n            legalOrders.legalConvoysByUnitID[curOrder.unitID][\n              maps.terrIDToProvince[curOrder.fromTerrID]\n            ],\n          ) as Province[];\n        } else {\n          provincesToHighlight = [\n            maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n          ];\n          provincesToChoose = Object.keys(\n            legalOrders.legalConvoysByUnitID[curOrder.unitID],\n          ) as Province[];\n        }\n      }\n    } else if (phase === \"Retreats\") {\n      if (!curOrder.inProgress) {\n        provincesToHighlight = [];\n        provincesToChoose = Object.keys(\n          legalOrders.legalRetreatDestsByUnitID,\n        ).map((unitID) => maps.terrIDToProvince[maps.unitToTerrID[unitID]]);\n      } else if (curOrder.type === \"Retreat\") {\n        provincesToHighlight = [\n          maps.terrIDToProvince[maps.unitToTerrID[curOrder.unitID]],\n        ];\n        provincesToChoose = legalOrders.legalRetreatDestsByUnitID[\n          curOrder.unitID\n        ].map((territory) => TerritoryMap[territory].province);\n        provincesToChoose.push(provincesToHighlight[0]);\n      }\n    } else if (phase === \"Builds\") {\n      if (user.member.supplyCenterNo < user.member.unitNo) {\n        provincesToChoose = units\n          .filter((unit) => unit.country === user.member.country)\n          .map((unit) => unit.mappedTerritory.province);\n      } else if (user.member.supplyCenterNo > user.member.unitNo) {\n        provincesToChoose = legalOrders.possibleBuildDests.map(\n          (territory) => TerritoryMap[territory].province,\n        );\n      }\n    }\n  }\n  const provincesToHighlightSet = new Set(provincesToHighlight);\n  const provincesToChooseSet = new Set(provincesToChoose);\n  // console.log({ provincesToChooseSet });\n\n  const unplayableProvinces = Object.values(provincesMapData)\n    .filter((data) => !data.playable)\n    .map((data) => {\n      return (\n        <WDProvince\n          provinceMapData={data}\n          ownerCountryID={centersByProvince[data.province]?.ownerCountryID}\n          playerCountryID={user?.member.countryID}\n          highlightSelection={false}\n          key={`${data.province}-province`}\n        />\n      );\n    });\n  // Hack - Rome and Naples need to be sorted to the end or else their label will get cut\n  // off by neighboring territories drawn on top of it.\n  const playableProvincesData = Object.values(provincesMapData).filter(\n    (data) =>\n      data.playable &&\n      data.province !== Province.NAPLES &&\n      data.province !== Province.ROME,\n  );\n  playableProvincesData.push(provincesMapData[Province.NAPLES]);\n  playableProvincesData.push(provincesMapData[Province.ROME]);\n\n  const playableProvinces = playableProvincesData.map((data) => {\n    const highlightSelection = provincesToHighlightSet.has(data.province);\n    return (\n      <WDProvince\n        provinceMapData={data}\n        ownerCountryID={centersByProvince[data.province]?.ownerCountryID}\n        playerCountryID={user?.member.countryID}\n        highlightSelection={highlightSelection}\n        key={`${data.province}-province`}\n      />\n    );\n  });\n\n  const playableProvinceOverlays = playableProvincesData.map((data) => {\n    const highlightChoice = provincesToChooseSet.has(data.province);\n    return (\n      <WDProvinceOverlay\n        provinceMapData={data}\n        units={units}\n        highlightChoice={highlightChoice}\n        key={`${data.province}-province-overlay`}\n      />\n    );\n  });\n\n  return (\n    <g id=\"wD-boardmap-v10.3.4 1\">\n      <g id=\"unplayable\">{unplayableProvinces}</g>\n      <g id=\"playableProvinces\">{playableProvinces}</g>\n      <g id=\"playableProvinceOverlays\">{playableProvinceOverlays}</g>\n    </g>\n  );\n};\n\nexport default WDBoardMap;\n","/* eslint-disable no-bitwise */\n\nenum BuildUnit {\n  Army = 1 << 1,\n  Fleet = 1 << 2,\n  All = Army | Fleet,\n}\n\nexport default BuildUnit;\n","import * as React from \"react\";\nimport ArrowColor from \"../../enums/ArrowColor\";\nimport ArrowType from \"../../enums/ArrowType\";\nimport webDiplomacyTheme from \"../../webDiplomacyTheme\";\n\nconst WDArrowMarkerColors = function (\n  arrowType: ArrowType,\n): React.ReactElement {\n  switch (arrowType) {\n    case ArrowType.SUPPORT:\n      return (\n        <>\n          {Object.entries(webDiplomacyTheme.palette.arrowColors).map(\n            ([arrowColor, config]) => (\n              <marker\n                id={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                key={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                markerWidth={12}\n                markerHeight={8}\n                refX={18}\n                refY={3}\n                orient=\"auto\"\n              >\n                <polygon\n                  points=\"0 0, 6 3, 0 6, 0 5, 4 3, 0 1\"\n                  fill={config.main}\n                />\n                <polygon\n                  points=\"4 0, 10 3, 4 6, 4 5, 8 3, 4 1\"\n                  fill={config.main}\n                />\n              </marker>\n            ),\n          )}\n        </>\n      );\n    case ArrowType.HOLD:\n      return (\n        <>\n          {Object.entries(webDiplomacyTheme.palette.arrowColors).map(\n            ([arrowColor, config]) => (\n              <marker\n                id={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                key={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                markerWidth={90}\n                markerHeight={90}\n                refX={10}\n                refY={45}\n                orient=\"auto\"\n                markerUnits=\"userSpaceOnUse\"\n                strokeWidth={4}\n              >\n                <path d=\" M 24 72 A 30 30 180 0 1 24 18\" stroke={config.main} />\n              </marker>\n            ),\n          )}\n        </>\n      );\n    default:\n      return (\n        <>\n          {Object.entries(webDiplomacyTheme.palette.arrowColors).map(\n            ([arrowColor, config]) => (\n              <marker\n                id={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                key={`arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]}`}\n                markerWidth={8}\n                markerHeight={8}\n                refX={\n                  (arrowColor as unknown as number) ===\n                  ArrowColor.IMPLIED_FOREIGN\n                    ? 0\n                    : 7.1\n                }\n                refY={4}\n                orient=\"auto\"\n              >\n                <polygon points=\"0 0, 8 4, 0 8\" fill={config.main} />\n              </marker>\n            ),\n          )}\n        </>\n      );\n  }\n};\n\nconst WDArrowMarkerDefs = function (): React.ReactElement {\n  return (\n    <>\n      {WDArrowMarkerColors(ArrowType.HOLD)}\n      {WDArrowMarkerColors(ArrowType.MOVE)}\n      {WDArrowMarkerColors(ArrowType.SUPPORT)}\n    </>\n  );\n};\n\nexport default WDArrowMarkerDefs;\n","import BuildUnit from \"../enums/BuildUnit\";\n\nexport const BuildUnitTypeMap = {\n  Army: BuildUnit.Army,\n  Fleet: BuildUnit.Fleet,\n  [BuildUnit.Army]: \"Army\",\n  [BuildUnit.Fleet]: \"Fleet\",\n} as const;\n\nconst BuildUnitMap = {\n  [BuildUnit.Army]: \"Build Army\",\n  [BuildUnit.Fleet]: \"Build Fleet\",\n  \"Build Army\": BuildUnit.Army,\n  \"Build Fleet\": BuildUnit.Fleet,\n} as const;\n\nexport default BuildUnitMap;\n","/* eslint-disable no-bitwise */\nimport * as React from \"react\";\nimport provincesMapData from \"../../../data/map/ProvincesMapData\";\nimport BuildUnit from \"../../../enums/BuildUnit\";\nimport Country from \"../../../enums/Country\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport UIState from \"../../../enums/UIState\";\nimport WDArmyIcon from \"../../ui/units/WDArmyIcon\";\nimport WDFleetIcon from \"../../ui/units/WDFleetIcon\";\n\nexport interface BuildData {\n  availableOrder: string;\n  clickCallback: (\n    availableOrder: BuildData[\"availableOrder\"],\n    canBuild: BuildData[\"canBuild\"],\n    toTerrID: BuildData[\"toTerrID\"],\n  ) => void;\n  country: Country;\n  canBuild: BuildUnit;\n  province: Province;\n  unitSlotName: string;\n  toTerrID: string;\n}\n\nconst WDBuildUnitButtons: React.FC<BuildData> = function ({\n  availableOrder,\n  clickCallback,\n  country,\n  canBuild,\n  province,\n  unitSlotName,\n  toTerrID,\n}): React.ReactElement {\n  const provinceMapData = provincesMapData[province];\n  let svgX =\n    provinceMapData.x + provinceMapData.unitSlotsBySlotName[unitSlotName].x;\n  let svgY =\n    provinceMapData.y + provinceMapData.unitSlotsBySlotName[unitSlotName].y;\n\n  let rw = 70;\n  const rh = 70;\n  const rBorder = 10;\n  const rFill = \"rgba(0,0,0,.7)\";\n  const buildButtons: React.ReactElement[] = [];\n  const iconStyle: React.CSSProperties = {\n    width: 50,\n    height: 50,\n  };\n  const groupStyle: React.CSSProperties = {\n    cursor: \"pointer\",\n  };\n\n  const cx = 0 + rw / 2;\n  const cy = 0 + rh / 2;\n  const r = 25;\n  const iconX = cx - r;\n  const iconY = cy - r;\n  svgY -= rh;\n  if (canBuild & BuildUnit.Army) {\n    buildButtons.push(\n      <g\n        key=\"Army\"\n        style={groupStyle}\n        onClick={() => {\n          clickCallback(availableOrder, BuildUnit.Army, toTerrID);\n        }}\n      >\n        <circle fill=\"white\" r={r} cx={cx} cy={cy} />\n        <svg x={iconX} y={iconY} style={iconStyle}>\n          <WDArmyIcon country={country} iconState={UIState.BUILD} />\n        </svg>\n      </g>,\n    );\n  }\n  if (canBuild & BuildUnit.Fleet) {\n    let shift = 0;\n    if (buildButtons.length) {\n      shift = rw - rBorder;\n      rw = rw * 2 - rBorder;\n    }\n    buildButtons.push(\n      <g\n        key=\"Fleet\"\n        style={groupStyle}\n        onClick={() => {\n          clickCallback(availableOrder, BuildUnit.Fleet, toTerrID);\n        }}\n      >\n        <circle fill=\"white\" r={r} cx={cx + shift} cy={cy} />\n        <svg x={iconX + shift} y={iconY} style={iconStyle}>\n          <WDFleetIcon country={country} iconState={UIState.BUILD} />\n        </svg>\n      </g>,\n    );\n  }\n  svgX -= rw / 2;\n  return (\n    <svg x={svgX} y={svgY}>\n      <rect\n        x={0}\n        y={0}\n        fill={rFill}\n        width={rw}\n        height={rh}\n        rx={rBorder}\n        ry={rBorder}\n      />\n      {buildButtons}\n    </svg>\n  );\n};\n\nexport default WDBuildUnitButtons;\n","/* eslint-disable no-bitwise */\nimport { Box } from \"@mui/material\";\nimport * as React from \"react\";\nimport BuildUnitMap from \"../../../data/BuildUnit\";\nimport countryMap from \"../../../data/map/variants/classic/CountryMap\";\nimport BuildUnit from \"../../../enums/BuildUnit\";\nimport {\n  gameApiSliceActions,\n  gameOrder,\n  gameTerritoriesMeta,\n  gameMaps,\n} from \"../../../state/game/game-api-slice\";\nimport { useAppDispatch, useAppSelector } from \"../../../state/hooks\";\nimport WDBuildUnitButtons from \"./WDBuildUnitButtons\";\nimport { TerritoryMeta } from \"../../../state/interfaces/TerritoriesState\";\nimport TerritoryMap from \"../../../data/map/variants/classic/TerritoryMap\";\nimport provincesMapData from \"../../../data/map/ProvincesMapData\";\n\nconst WDBuildContainer: React.FC = function (): React.ReactElement {\n  const dispatch = useAppDispatch();\n  const maps = useAppSelector(gameMaps);\n\n  const build = (availableOrder, canBuild, toTerrID) => {\n    // console.log(\n    //   `Dispatched a build ${canBuild} ${BuildUnitMap[canBuild]} ${toTerrID}`,\n    // );\n    let terrIDToBuildOn = toTerrID;\n    if (BuildUnitMap[canBuild] === \"Build Army\") {\n      // If we initiated a build popup onto a special coast but the user\n      // chose to build an army, make sure the army gets built on the province\n      // root territory rather than a special coast.\n      terrIDToBuildOn = maps.terrIDToProvinceID[toTerrID];\n    }\n    dispatch(\n      gameApiSliceActions.updateOrdersMeta({\n        [availableOrder]: {\n          saved: false,\n          update: {\n            type: BuildUnitMap[canBuild],\n            toTerrID: terrIDToBuildOn,\n          },\n        },\n      }),\n    );\n    dispatch(gameApiSliceActions.resetOrder());\n  };\n  const order = useAppSelector(gameOrder);\n  const userMember = useAppSelector(\n    (state) => state.game.overview.user!.member,\n  );\n  if (!order || order.type !== \"Build\") {\n    return <Box />;\n  }\n  const territory = maps.terrIDToTerritory[order.toTerrID];\n  const { province, unitSlotName } = TerritoryMap[territory];\n  const canBuild =\n    provincesMapData[province].type === \"Coast\"\n      ? BuildUnit.All\n      : BuildUnit.Army;\n  return (\n    <WDBuildUnitButtons\n      key={`${province}-${unitSlotName}`}\n      availableOrder={order.orderID}\n      canBuild={canBuild}\n      clickCallback={build}\n      country={countryMap[userMember.country]}\n      province={province}\n      unitSlotName={unitSlotName}\n      toTerrID={order.toTerrID}\n    />\n  );\n};\n\nexport default WDBuildContainer;\n","/* eslint-disable no-bitwise */\nimport * as React from \"react\";\nimport { Box, Button, Stack } from \"@mui/material\";\nimport {\n  gameApiSliceActions,\n  gameOrder,\n} from \"../../../state/game/game-api-slice\";\nimport { useAppDispatch, useAppSelector } from \"../../../state/hooks\";\nimport WDBuildUnitButtons from \"./WDBuildUnitButtons\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport provincesMapData from \"../../../data/map/ProvincesMapData\";\n\ntype Position = \"left\" | \"right\" | \"top\" | \"bottom\";\n\ninterface WDOrderTypeButtonProps {\n  province: Province;\n  unitSlotName: string;\n  position: Position;\n  text: string;\n  clickHandler: () => void;\n}\n\nconst WDFlyoutButton: React.FC<WDOrderTypeButtonProps> = function ({\n  province,\n  unitSlotName,\n  position,\n  text,\n  clickHandler,\n}): React.ReactElement {\n  const dispatch = useAppDispatch();\n  const provinceMapData = provincesMapData[province];\n  if (!provinceMapData || !provinceMapData.unitSlotsBySlotName[unitSlotName])\n    return <Box />;\n\n  const unitX =\n    provinceMapData.x + provinceMapData.unitSlotsBySlotName[unitSlotName].x;\n  const unitY =\n    provinceMapData.y + provinceMapData.unitSlotsBySlotName[unitSlotName].y;\n\n  const fontSize = 24;\n  const rw = 55 + fontSize * text.length * 0.4;\n  const rh = 45 + fontSize;\n  const rBorder = 35;\n  const rFill = \"rgba(0,0,0,.7)\";\n  const groupStyle: React.CSSProperties = {\n    cursor: \"pointer\",\n  };\n  let shiftX = 0;\n  let shiftY = 0;\n  const shiftOffset = 50;\n  if (position === \"top\") {\n    shiftY = -(rh / 2 + shiftOffset);\n  } else if (position === \"bottom\") {\n    shiftY = +(rh / 2 + shiftOffset);\n  } else if (position === \"left\") {\n    shiftX = -(rw / 2 + shiftOffset);\n  } else if (position === \"right\") {\n    shiftX = +(rw / 2 + shiftOffset);\n  } else {\n    throw Error(position);\n  }\n  const svgX = unitX - rw / 2 + shiftX;\n  const svgY = unitY - rh / 2 + shiftY;\n\n  /*\n   * r is the circle radius\n  cx and cy are offsets\n  rx and ry and rounded edges\n   */\n  return (\n    <svg\n      x={svgX}\n      y={svgY}\n      filter=\"drop-shadow(10px 10px 18px #222222)\"\n      onClick={clickHandler}\n    >\n      <g style={groupStyle}>\n        <rect\n          x={0}\n          y={0}\n          fill=\"white\"\n          width={rw}\n          height={rh}\n          rx={rBorder}\n          ry={rBorder}\n        />\n        <text\n          x={rw / 2}\n          y={rh / 2}\n          textAnchor=\"middle\"\n          alignmentBaseline=\"middle\"\n          fontFamily=\"Roboto\"\n          fontSize={fontSize}\n          style={{\n            userSelect: \"none\",\n          }}\n          fill=\"black\"\n        >\n          {text}\n        </text>\n      </g>\n    </svg>\n  );\n};\n\nexport default WDFlyoutButton;\n","/* eslint-disable no-bitwise */\nimport * as React from \"react\";\nimport { Box, Button, Stack } from \"@mui/material\";\nimport {\n  gameApiSliceActions,\n  gameLegalOrders,\n  gameMaps,\n  gameOrder,\n} from \"../../../state/game/game-api-slice\";\nimport { useAppDispatch, useAppSelector } from \"../../../state/hooks\";\nimport Territory from \"../../../enums/map/variants/classic/Territory\";\nimport Province from \"../../../enums/map/variants/classic/Province\";\nimport { Unit } from \"../../../utils/map/getUnits\";\n\nimport WDFlyoutButton from \"./WDFlyoutButton\";\nimport TerritoryMap from \"../../../data/map/variants/classic/TerritoryMap\";\n\ninterface WDFlyoutContainerProps {\n  units: Unit[];\n}\n\nconst WDFlyoutContainer: React.FC<WDFlyoutContainerProps> = function ({\n  units,\n}): React.ReactElement {\n  const dispatch = useAppDispatch();\n  const order = useAppSelector(gameOrder);\n  const maps = useAppSelector(gameMaps);\n  const legalOrders = useAppSelector(gameLegalOrders);\n\n  // console.log(\"FLYOUT\");\n  // console.log({ order });\n\n  if (!order.inProgress || order.type || !order.unitID) {\n    return <Box />;\n  }\n\n  const unit = units.find((u) => u.unit.id === order.unitID);\n\n  const mTerr = TerritoryMap[maps.unitToTerritory[order.unitID]];\n  const { province, unitSlotName } = mTerr;\n  const clickHandler =\n    (orderType, viaConvoy: string | undefined = undefined) =>\n    () => {\n      // console.log(`Dispatched ${orderType}`);\n      dispatch(\n        gameApiSliceActions.updateOrder({\n          type: orderType,\n          viaConvoy,\n        }),\n      );\n    };\n  return (\n    <>\n      <WDFlyoutButton\n        province={province}\n        unitSlotName={unitSlotName}\n        position=\"left\"\n        text=\"Hold\"\n        clickHandler={clickHandler(\"Hold\")}\n      />\n      <WDFlyoutButton\n        province={province}\n        unitSlotName={unitSlotName}\n        position=\"right\"\n        text=\"Move\"\n        clickHandler={clickHandler(\"Move\")}\n      />\n      <WDFlyoutButton\n        province={province}\n        unitSlotName={unitSlotName}\n        position=\"top\"\n        text=\"Support\"\n        clickHandler={clickHandler(\"Support\")}\n      />\n      {(unit?.unit?.type === \"Fleet\" &&\n        mTerr.provinceMapData.type === \"Sea\" &&\n        legalOrders.hasAnyLegalConvoysByUnitID[order.unitID] && (\n          <WDFlyoutButton\n            province={province}\n            unitSlotName={unitSlotName}\n            position=\"bottom\"\n            text=\"Convoy\"\n            clickHandler={clickHandler(\"Convoy\")}\n          />\n        )) || <g />}\n      {unit?.unit?.type === \"Army\" &&\n        legalOrders.legalViasByUnitID[order.unitID].length > 0 && (\n          <WDFlyoutButton\n            province={province}\n            unitSlotName={unitSlotName}\n            position=\"bottom\"\n            text=\"Via Convoy\"\n            clickHandler={clickHandler(\"Move\", \"Yes\")}\n          />\n        )}\n    </>\n  );\n};\n\nexport default WDFlyoutContainer;\n","import * as React from \"react\";\nimport ArrowColor from \"../../enums/ArrowColor\";\nimport ArrowType from \"../../enums/ArrowType\";\nimport Territory from \"../../enums/map/variants/classic/Territory\";\nimport webDiplomacyTheme from \"../../webDiplomacyTheme\";\nimport arrowDispatchReceiveCoordinates from \"./arrowDispatchReceiveCoordinates\";\nimport TerritoryMap from \"../../data/map/variants/classic/TerritoryMap\";\nimport { UNIT_HEIGHT, UNIT_WIDTH } from \"../../components/ui/units/WDUnit\";\n\n// Returns the coordinates of the upper left corner of the source or destination\n// of an arrow, and the source or destination object's width and height.\n// Type and identifier specify what object the arrow is pointing to, which is\n// necessary for targeting and spacing the arrow appropriately.\n// If type is \"arrow\", then identifier must be a 4-tuple of the coordinates\n// [x1, y1, x2, y2] of that arrow.\n// For all other types, identifier must be a Territory.\nexport function getTargetXYWH(\n  type: \"territory\" | \"unit\" | \"arrow\" | \"dislodger\",\n  identifier: Territory | [number, number, number, number],\n): [number, number, number, number] {\n  let x;\n  let y;\n  let width;\n  let height;\n\n  switch (type) {\n    case \"arrow\": {\n      // If the target of this arrow is itself an arrow, then target a point\n      // attachPoint proportion of the way along that arrow.\n      const [arrowX1, arrowY1, arrowX2, arrowY2] = identifier as [\n        number,\n        number,\n        number,\n        number,\n      ];\n      const attachPoint = 0.75;\n      const run = arrowX2 - arrowX1;\n      const rise = arrowY2 - arrowY1;\n\n      x = arrowX1 + run * attachPoint;\n      y = arrowY1 + rise * attachPoint;\n      width = 0;\n      height = 0;\n      break;\n    }\n    // If the target of this arrow is a unit, then (regardless of whether the\n    // unit drawing code actually draws a unit there), draw an arrow to the\n    // slot that the unit would be placed at, spaced appropriately for the size\n    // that unit's icon would be.\n    case \"unit\": {\n      const toTerritoryName = Territory[identifier as Territory];\n      const toTerritoryData = TerritoryMap[toTerritoryName].provinceMapData;\n      const { unitSlotName } = TerritoryMap[toTerritoryName];\n\n      x = toTerritoryData.x;\n      y = toTerritoryData.y;\n      if (toTerritoryData.unitSlotsBySlotName[unitSlotName]) {\n        x += toTerritoryData.unitSlotsBySlotName[unitSlotName].x;\n        y += toTerritoryData.unitSlotsBySlotName[unitSlotName].y;\n      }\n      width = UNIT_WIDTH;\n      height = UNIT_HEIGHT;\n      break;\n    }\n    // Units on retreat phases that are dislodging another unit are placed in\n    // the arrow receiver slot rather than in the normal unit drawing slot.\n    // This is so they don't overlap the drawing of the unit in that territory\n    // that needs to perform a retreat.\n    // So when drawing an arrow to a dislodger, we need to point at the\n    // arrow receiver slot instead.\n    case \"dislodger\": {\n      const toTerritoryName = Territory[identifier as Territory];\n      const toTerritoryData = TerritoryMap[toTerritoryName].provinceMapData;\n      const { unitSlotName } = TerritoryMap[toTerritoryName];\n\n      x = toTerritoryData.x;\n      y = toTerritoryData.y;\n      if (toTerritoryData.unitSlotsBySlotName[unitSlotName]) {\n        x += toTerritoryData.unitSlotsBySlotName[unitSlotName].arrowReceiver.x;\n        y += toTerritoryData.unitSlotsBySlotName[unitSlotName].arrowReceiver.y;\n      }\n      width = UNIT_WIDTH;\n      height = UNIT_HEIGHT;\n      break;\n    }\n    // Otherwise, draw an arrow pointing to the arrow receiver slot of the\n    // territory. We still draw the arrow as if pointing to an object\n    // of a small buffersize many pixels. That way, the arrows stop slightly short\n    // of the exact target location. This looks a bit nicer when\n    // multiple arrows point to the same territory - the arrow points\n    // stop slightly short of each other instead of all overlapping.\n    default: {\n      const toTerritoryName = Territory[identifier as Territory];\n      const toTerritoryData = TerritoryMap[toTerritoryName].provinceMapData;\n      const { unitSlotName } = TerritoryMap[toTerritoryName];\n\n      const bufferSize = 12;\n\n      x = toTerritoryData.x;\n      y = toTerritoryData.y;\n      if (toTerritoryData.unitSlotsBySlotName[unitSlotName]) {\n        x += toTerritoryData.unitSlotsBySlotName[unitSlotName].arrowReceiver.x;\n        y += toTerritoryData.unitSlotsBySlotName[unitSlotName].arrowReceiver.y;\n      }\n      width = bufferSize;\n      height = bufferSize;\n      break;\n    }\n  }\n\n  return [x, y, width, height];\n}\n\n// See getTargetXYWH for a description of the possible types and identifiers.\nexport function getArrowX1Y1X2Y2(\n  sourceType: \"territory\" | \"unit\" | \"arrow\" | \"dislodger\",\n  sourceIdentifier: Territory | [number, number, number, number],\n  receiverType: \"territory\" | \"unit\" | \"arrow\" | \"dislodger\",\n  receiverIdentifier: Territory | [number, number, number, number],\n): [number, number, number, number] {\n  // Source of arrow\n  // eslint-disable-next-line prefer-const\n  let [sx1, sy1, sourceWidth, sourceHeight] = getTargetXYWH(\n    sourceType,\n    sourceIdentifier,\n  );\n  const [rx2, ry2, receiverWidth, receiverHeight] = getTargetXYWH(\n    receiverType,\n    receiverIdentifier,\n  );\n\n  // Draw the arrows slightly closer to a unit than their nominal size for the arrow source, the portion of\n  // the unit's nominal size that the unit icon actually covers is a bit smaller and\n  // the arrow looks a bit too far away otherwise.\n  const UNIT_SOURCE_SHRINK_FACTOR = 0.9;\n  if (sourceType === \"unit\" || sourceType === \"dislodger\") {\n    sourceWidth *= UNIT_SOURCE_SHRINK_FACTOR;\n    sourceHeight *= UNIT_SOURCE_SHRINK_FACTOR;\n  }\n\n  const { x1, x2, y1, y2 } = arrowDispatchReceiveCoordinates(\n    sourceHeight,\n    sourceWidth,\n    receiverHeight,\n    receiverWidth,\n    sx1,\n    rx2,\n    sy1,\n    ry2,\n  );\n\n  return [x1, y1, x2, y2];\n}\n\n// See getTargetXYWH for a description of the possible types and identifiers.\n// If skipDrawingProportion is specified, will skip drawing the first\n// skipDrawingProportion-th of the line segment of the arrow.\nexport default function drawArrowFunctional(\n  arrowType: ArrowType,\n  arrowColor: ArrowColor,\n  sourceType: \"territory\" | \"unit\" | \"arrow\" | \"dislodger\",\n  sourceIdentifier: Territory | [number, number, number, number],\n  receiverType: \"territory\" | \"unit\" | \"arrow\" | \"dislodger\",\n  receiverIdentifier: Territory | [number, number, number, number],\n  offsetArrowSourcePixels = 0.0,\n): React.ReactElement {\n  // console.log(\n  //   `drawArrowFunctional ${sourceIdentifier} ${receiverType} ${receiverIdentifier} `,\n  // );\n  // eslint-disable-next-line prefer-const\n  let [x1, y1, x2, y2] = getArrowX1Y1X2Y2(\n    sourceType,\n    sourceIdentifier,\n    receiverType,\n    receiverIdentifier,\n  );\n\n  let strokeDasharray: string | undefined;\n  if (arrowType === ArrowType.CONVOY) {\n    strokeDasharray = \"4 3\";\n  } else if (arrowType === ArrowType.HOLD) {\n    strokeDasharray = \"12 3\";\n  }\n\n  let strokeWidth;\n  switch (arrowColor) {\n    case ArrowColor.MOVE:\n    case ArrowColor.CONVOY:\n    case ArrowColor.IMPLIED:\n    case ArrowColor.IMPLIED_FOREIGN:\n    case ArrowColor.RETREAT:\n    case ArrowColor.SUPPORT_HOLD:\n    case ArrowColor.SUPPORT_MOVE:\n      strokeWidth = 3.5;\n      break;\n    case ArrowColor.MOVE_FAILED:\n    case ArrowColor.CONVOY_FAILED:\n    case ArrowColor.SUPPORT_HOLD_FAILED:\n    case ArrowColor.SUPPORT_MOVE_FAILED:\n      strokeWidth = 3;\n      break;\n    default:\n      strokeWidth = 3.5;\n  }\n\n  if (offsetArrowSourcePixels > 0) {\n    // Offset the source location perpendicular to the direction of travel by\n    // offsetArrowSourcePixels distance.\n    // Start by finding a unit vector in the direction of the arrows\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    if (length > 0) {\n      const dxunit = dx / length;\n      const dyunit = dy / length;\n      // Rotate 90 degrees\n      const dxunitRotated = dyunit;\n      const dyunitRotated = -dxunit;\n      // Add the desired number of pixels\n      x1 += offsetArrowSourcePixels * dxunitRotated;\n      y1 += offsetArrowSourcePixels * dyunitRotated;\n    }\n  }\n\n  return (\n    <line\n      key={`${x1}-${y1}-${x2}-${y2}-${arrowType}-${arrowColor}`}\n      x1={x1}\n      y1={y1}\n      x2={x2}\n      y2={y2}\n      markerEnd={`url(#arrowHead__${ArrowType[arrowType]}_${ArrowColor[arrowColor]})`}\n      stroke={webDiplomacyTheme.palette.arrowColors[arrowColor].main}\n      strokeWidth={strokeWidth}\n      strokeDasharray={strokeDasharray}\n    />\n  );\n}\n","export default function arrowDispatchReceiveCoordinates(\n  unitH: number, // dispatch unit height\n  unitW: number, // dispatch unit width\n  rh: number, // receiver height\n  rw: number, // receiver width\n  x1: number, // line x1\n  x2: number, // line x2\n  y1: number, // line y1\n  y2: number, // line y2\n): {\n  x1: number;\n  x2: number;\n  y1: number;\n  y2: number;\n} {\n  // Compute the angle that we need the arrow to go at\n  // If there isn't an angle because the diff is too small, quit out immediately\n  const xDiff = x2 - x1;\n  const yDiff = y2 - y1;\n  if (Math.abs(xDiff) <= 1e-10 && Math.abs(yDiff) <= 1e-10) {\n    return {\n      x1,\n      x2,\n      y1,\n      y2,\n    };\n  }\n  const theta = Math.atan2(yDiff, xDiff);\n\n  // Make the arrow start at the border of the ellipse with the specified\n  // width and height.\n  const x1New = x1 + (unitW / 2) * Math.cos(theta);\n  const y1New = y1 + (unitH / 2) * Math.sin(theta);\n\n  // Make the arrow end at the border of the ellipse with the specified\n  // width and height.\n  const x2New = x2 - (rw / 2) * Math.cos(theta);\n  const y2New = y2 - (rh / 2) * Math.sin(theta);\n\n  // If the result would give an arrow that points backwards, due to overlap\n  // between the source and destination then give up and don't do adjustment\n  // for the source and receiver width and height.\n  // Determine if it points backwards by dot product with the original vector\n  const xDiffNew = x2New - x1New;\n  const yDiffNew = y2New - y1New;\n  if (xDiffNew * xDiff + yDiffNew * yDiff <= 1e-10) {\n    return {\n      x1,\n      x2,\n      y1,\n      y2,\n    };\n  }\n\n  return {\n    x1: x1New,\n    x2: x2New,\n    y1: y1New,\n    y2: y2New,\n  };\n}\n","/* eslint-disable no-bitwise */\nimport * as React from \"react\";\nimport countryMap from \"../../../data/map/variants/classic/CountryMap\";\nimport { IOrderDataHistorical } from \"../../../models/Interfaces\";\nimport {\n  gameApiSliceActions,\n  gameOverview,\n  gameTerritoriesMeta,\n} from \"../../../state/game/game-api-slice\";\nimport { useAppDispatch, useAppSelector } from \"../../../state/hooks\";\nimport GameStateMaps from \"../../../state/interfaces/GameStateMaps\";\nimport ArrowType from \"../../../enums/ArrowType\";\nimport ArrowColor from \"../../../enums/ArrowColor\";\nimport drawArrowFunctional, {\n  getTargetXYWH,\n  getArrowX1Y1X2Y2,\n} from \"../../../utils/map/drawArrowFunctional\";\nimport TerritoryMap from \"../../../data/map/variants/classic/TerritoryMap\";\nimport { APITerritories } from \"../../../state/interfaces/GameDataResponse\";\nimport { Unit, UnitDrawMode } from \"../../../utils/map/getUnits\";\n\nfunction accumulateMoveOrderArrows(\n  arrows: (React.ReactElement | null)[],\n  orders: IOrderDataHistorical[],\n  territories: APITerritories,\n): void {\n  // console.log(\"drawMoveOrders\");\n  orders\n    .filter((order) => order.type === \"Move\")\n    .forEach((order) => {\n      if (!order.toTerrID) {\n        return;\n      }\n      // console.log({\n      //   order,\n      //   territories,\n      //   terrID: order.terrID,\n      //   lookup: territories[order.terrID],\n      // });\n      const fromTerr = TerritoryMap[territories[order.terrID].name].territory;\n      const toTerr = TerritoryMap[territories[order.toTerrID].name].territory;\n\n      arrows.push(\n        drawArrowFunctional(\n          ArrowType.MOVE,\n          order.success === \"Yes\" ? ArrowColor.MOVE : ArrowColor.MOVE_FAILED,\n          \"unit\",\n          fromTerr,\n          \"territory\",\n          toTerr,\n        ),\n      );\n      // console.log(\"ARROW\");\n      // console.log(arrows[0]);\n\n      if (order.viaConvoy === \"Yes\") {\n        // TODO need to distinguish via vs nonvia orders??\n      }\n    });\n}\n\nfunction getProvIDNumberOfTerrIDNumber(\n  terrID: number,\n  territories: APITerritories,\n): number {\n  if (territories[terrID]?.coastParentID) {\n    return Number(territories[terrID].coastParentID);\n  }\n  return terrID;\n}\n\nfunction accumulateSupportHoldOrderArrows(\n  arrows: (React.ReactElement | null)[],\n  orders: IOrderDataHistorical[],\n  ordersByProvID: { [key: number]: IOrderDataHistorical },\n  territories: APITerritories,\n): void {\n  // Maps supportee and supporter provIDs to help us find mutual supports.\n  const supporterProvIDToSupporteeProvID: { [key: number]: number } = {};\n  orders\n    .filter((order) => order.type === \"Support hold\")\n    .forEach((order) => {\n      const provID = getProvIDNumberOfTerrIDNumber(order.terrID, territories);\n      // Support orders toTerrID are always provinces\n      const supporteeProvID = order.toTerrID;\n      supporterProvIDToSupporteeProvID[provID] = supporteeProvID;\n    });\n  // console.log({ supporterProvIDToSupporteeProvID });\n\n  orders\n    .filter((order) => order.type === \"Support hold\")\n    .forEach((order) => {\n      if (!order.toTerrID) {\n        return;\n      }\n      const supporterProvID = getProvIDNumberOfTerrIDNumber(\n        order.terrID,\n        territories,\n      );\n      const supporterTerr =\n        TerritoryMap[territories[order.terrID].name].territory;\n\n      // Support orders toTerrID are actually always provinces\n      const supporteeProvID = order.toTerrID;\n      const supporteeOrder = ordersByProvID[supporteeProvID];\n\n      // If the supportee order is found at all, use it for the\n      // supportee territory since it is a territory id whereas the supporter's\n      // order might be province id.\n      const supporteeTerr = supporteeOrder\n        ? TerritoryMap[territories[supporteeOrder.terrID].name].territory\n        : TerritoryMap[territories[order.toTerrID].name].territory;\n\n      const arrowColor =\n        order.success === \"Yes\"\n          ? ArrowColor.SUPPORT_HOLD\n          : ArrowColor.SUPPORT_HOLD_FAILED;\n\n      // In case of a mutual support hold, offset the support line by a few pixels\n      // so that the corresponding returning support line from the other order\n      // doesn't overlap with it.\n      const hasMutualSupport =\n        supporterProvIDToSupporteeProvID[supporteeProvID] === supporterProvID;\n      const offsetArrowSourcePixels = hasMutualSupport ? 6 : 0;\n      // console.log({\n      //   supporteeProvID,\n      //   supporterProvID,\n      //   hasMutualSupport,\n      //   offsetArrowSourcePixels,\n      // });\n\n      arrows.push(\n        drawArrowFunctional(\n          ArrowType.HOLD,\n          arrowColor,\n          \"unit\",\n          supporterTerr,\n          \"unit\",\n          supporteeTerr,\n          offsetArrowSourcePixels,\n        ),\n      );\n    });\n}\n\nfunction accumulateSupportMoveOrderArrows(\n  arrows: (React.ReactElement | null)[],\n  orders: IOrderDataHistorical[],\n  ordersByProvID: { [key: number]: IOrderDataHistorical },\n  territories: APITerritories,\n): void {\n  orders\n    .filter((order) => order.type === \"Support move\")\n    .forEach((order) => {\n      if (!(order.fromTerrID && order.toTerrID)) {\n        return;\n      }\n\n      const supporterTerr =\n        TerritoryMap[territories[order.terrID].name].territory;\n      let isCoordinated = false;\n      // Support orders fromTerrID are actually always provinces\n      const supporteeProvID = order.fromTerrID;\n      const supporteeOrder = ordersByProvID[supporteeProvID];\n      if (\n        supporteeOrder &&\n        supporteeOrder.type === \"Move\" &&\n        (supporteeOrder.terrID === order.fromTerrID ||\n          territories[supporteeOrder.terrID].coastParentID ===\n            order.fromTerrID.toString()) &&\n        (supporteeOrder.toTerrID === order.toTerrID ||\n          territories[supporteeOrder.toTerrID].coastParentID ===\n            order.toTerrID.toString())\n      ) {\n        isCoordinated = true;\n      }\n\n      // If the supportee order is found at all, use it for the\n      // supportee territory since it is coast qualified whereas the supporter's\n      // order does not have to be coast qualified.\n      const supporteeTerr = supporteeOrder\n        ? TerritoryMap[territories[supporteeOrder.terrID].name].territory\n        : TerritoryMap[territories[order.fromTerrID].name].territory;\n\n      const arrowColor =\n        order.success === \"Yes\"\n          ? ArrowColor.SUPPORT_MOVE\n          : ArrowColor.SUPPORT_MOVE_FAILED;\n\n      if (isCoordinated) {\n        // For coordinated supports, use the order for the supportee for determining\n        // the destination location because the destination of the supportee order\n        // must be coast-qualified whereas the locations of the supporter order\n        // does not have to be coast-qualified.\n        const toTerr =\n          TerritoryMap[territories[supporteeOrder.toTerrID].name].territory;\n\n        arrows.push(\n          drawArrowFunctional(\n            ArrowType.SUPPORT,\n            arrowColor,\n            \"unit\",\n            supporterTerr,\n            \"arrow\",\n            getArrowX1Y1X2Y2(\"unit\", supporteeTerr, \"territory\", toTerr),\n          ),\n        );\n      } else {\n        // Uncoordinated supports\n        const toTerr = TerritoryMap[territories[order.toTerrID].name].territory;\n        arrows.push(\n          drawArrowFunctional(\n            ArrowType.SUPPORT,\n            arrowColor,\n            \"unit\",\n            supporterTerr,\n            \"arrow\",\n            getArrowX1Y1X2Y2(\"unit\", supporteeTerr, \"territory\", toTerr),\n          ),\n        );\n        // Also draw a ghosty arrow of what we're trying to support.\n        arrows.push(\n          drawArrowFunctional(\n            ArrowType.MOVE,\n            ArrowColor.IMPLIED_FOREIGN,\n            \"unit\",\n            supporteeTerr,\n            \"territory\",\n            toTerr,\n          ),\n        );\n      }\n    });\n}\n\nfunction accumulateConvoyOrderArrows(\n  arrows: (React.ReactElement | null)[],\n  orders: IOrderDataHistorical[],\n  ordersByProvID: { [key: number]: IOrderDataHistorical },\n  territories: APITerritories,\n): void {\n  orders\n    .filter((order) => order.type === \"Convoy\")\n    .forEach((order) => {\n      if (!(order.fromTerrID && order.toTerrID)) {\n        return;\n      }\n\n      const convoyerTerr =\n        TerritoryMap[territories[order.terrID].name].territory;\n      const convoyeeTerr =\n        TerritoryMap[territories[order.fromTerrID].name].territory;\n      let isCoordinated = false;\n      // Convoyees are always armies, whose terrIDs and provIDs match\n      const convoyeeOrder = ordersByProvID[order.fromTerrID];\n      if (\n        convoyeeOrder &&\n        convoyeeOrder.type === \"Move\" &&\n        convoyeeOrder.terrID === order.fromTerrID &&\n        (convoyeeOrder.toTerrID === order.toTerrID ||\n          territories[convoyeeOrder.toTerrID].coastParentID ===\n            order.toTerrID.toString())\n      ) {\n        isCoordinated = true;\n      }\n\n      const arrowColor =\n        order.success === \"Yes\" ? ArrowColor.CONVOY : ArrowColor.CONVOY_FAILED;\n\n      const toTerr = TerritoryMap[territories[order.toTerrID].name].territory;\n      arrows.push(\n        drawArrowFunctional(\n          ArrowType.CONVOY,\n          arrowColor,\n          \"unit\",\n          convoyerTerr,\n          \"arrow\",\n          getArrowX1Y1X2Y2(\"unit\", convoyeeTerr, \"territory\", toTerr),\n        ),\n      );\n      if (!isCoordinated) {\n        // Also draw a ghosty arrow of what we're trying to convoy.\n        arrows.push(\n          drawArrowFunctional(\n            ArrowType.MOVE,\n            ArrowColor.IMPLIED_FOREIGN,\n            \"unit\",\n            convoyeeTerr,\n            \"territory\",\n            toTerr,\n          ),\n        );\n      }\n    });\n}\n\nfunction accumulateRetreatArrows(\n  arrows: (React.ReactElement | null)[],\n  orders: IOrderDataHistorical[],\n  territories: APITerritories,\n): void {\n  orders\n    .filter((order) => order.type === \"Retreat\")\n    .forEach((order) => {\n      if (!order.toTerrID) {\n        return;\n      }\n      const fromTerr = TerritoryMap[territories[order.terrID].name].territory;\n      const toTerr = TerritoryMap[territories[order.toTerrID].name].territory;\n\n      arrows.push(\n        drawArrowFunctional(\n          ArrowType.MOVE,\n          ArrowColor.RETREAT,\n          \"unit\",\n          fromTerr,\n          \"territory\",\n          toTerr,\n        ),\n      );\n    });\n}\n\nfunction accumulateDislodgerArrows(\n  arrows: (React.ReactElement | null)[],\n  units: Unit[],\n  territories: APITerritories,\n): void {\n  units\n    .filter((unit) => unit.drawMode === UnitDrawMode.DISLODGING)\n    .forEach((unit) => {\n      if (unit.movedFromTerrID === null) return;\n      const fromTerr =\n        TerritoryMap[territories[unit.movedFromTerrID].name].territory;\n      const toTerr = TerritoryMap[territories[unit.unit.terrID].name].territory;\n\n      arrows.push(\n        drawArrowFunctional(\n          ArrowType.MOVE,\n          ArrowColor.MOVE,\n          \"territory\",\n          fromTerr,\n          \"dislodger\",\n          toTerr,\n        ),\n      );\n    });\n}\n\n// This isn't exactly an arrow, but...\nfunction accumulateBuildCircles(\n  arrows: (React.ReactElement | null)[],\n  units: Unit[],\n  territories: APITerritories,\n): void {\n  units\n    .filter((unit) => unit.drawMode === UnitDrawMode.BUILD)\n    .forEach((unit) => {\n      const terr = TerritoryMap[territories[unit.unit.terrID].name].territory;\n      const [x, y, w, h] = getTargetXYWH(\"unit\", terr);\n\n      arrows.push(\n        <circle\n          key={`build-circle-${terr}`}\n          cx={x}\n          cy={y}\n          r={(1.4 * (w + h)) / 4}\n          fill=\"none\"\n          stroke=\"rgb(0,150,0)\"\n          strokeWidth={0.05 * (w + h)}\n        />,\n      );\n    });\n}\n/*\nexport interface IOrderDataHistorical {\n  countryID: string;\n  dislodged: string;\n  fromTerrID: number;\n  phase: string;\n  success: string;\n  terrID: number;\n  toTerrID: number;\n  turn: number;\n  type: string;\n  unitType: string;\n  viaConvoy: string;\n}\n*/\n\ninterface WDArrowProps {\n  phase: string;\n  orders: IOrderDataHistorical[];\n  units: Unit[];\n  maps: GameStateMaps;\n  territories: APITerritories;\n}\n\nconst WDArrowContainer: React.FC<WDArrowProps> = function ({\n  phase,\n  orders,\n  units,\n  maps,\n  territories,\n}): React.ReactElement {\n  const arrows: (React.ReactElement | null)[] = [];\n\n  const ordersByProvID = {};\n  orders.forEach((order) => {\n    ordersByProvID[getProvIDNumberOfTerrIDNumber(order.terrID, territories)] =\n      order;\n  });\n  accumulateMoveOrderArrows(arrows, orders, territories);\n  accumulateSupportHoldOrderArrows(arrows, orders, ordersByProvID, territories);\n  accumulateSupportMoveOrderArrows(arrows, orders, ordersByProvID, territories);\n  accumulateConvoyOrderArrows(arrows, orders, ordersByProvID, territories);\n  accumulateRetreatArrows(arrows, orders, territories);\n  accumulateDislodgerArrows(arrows, units, territories);\n  accumulateBuildCircles(arrows, units, territories);\n  return <g id=\"arrows\">{arrows}</g>;\n};\n\nexport default WDArrowContainer;\n","import * as React from \"react\";\nimport WDBoardMap from \"./variants/classic/components/WDBoardMap\";\nimport CapturableLandTexture from \"../../assets/textures/capturable-land.jpeg\";\nimport WaterTexture from \"../../assets/textures/sea-texture.png\";\nimport WDArrowMarkerDefs from \"../../utils/map/WDArrowMarkerDefs\";\nimport WDBuildContainer from \"./components/WDBuildContainer\";\nimport WDFlyoutContainer from \"./components/WDFlyoutContainer\";\nimport WDArrowContainer from \"./components/WDArrowContainer\";\nimport { Unit } from \"../../utils/map/getUnits\";\nimport { IOrderDataHistorical } from \"../../models/Interfaces\";\nimport GameStateMaps from \"../../state/interfaces/GameStateMaps\";\nimport { APITerritories } from \"../../state/interfaces/GameDataResponse\";\nimport Territory from \"../../enums/map/variants/classic/Territory\";\n\ninterface WDMapProps {\n  units: Unit[];\n  phase: string;\n  orders: IOrderDataHistorical[];\n  maps: GameStateMaps;\n  territories: APITerritories;\n  centersByProvince: { [key: string]: { ownerCountryID: string } };\n  isLatestPhase: boolean;\n}\n\nconst WDMap: React.ForwardRefExoticComponent<\n  WDMapProps & React.RefAttributes<SVGSVGElement>\n> = React.forwardRef<SVGSVGElement, WDMapProps>(\n  (\n    {\n      units,\n      phase,\n      orders,\n      maps,\n      territories,\n      centersByProvince,\n      isLatestPhase,\n    },\n    ref,\n  ): React.ReactElement => (\n    <svg\n      id=\"map\"\n      fill=\"none\"\n      ref={ref}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n      }}\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <g id=\"full-map-svg\">\n        <g id=\"container\">\n          <WDBoardMap\n            units={units}\n            centersByProvince={centersByProvince}\n            phase={phase}\n            isLatestPhase={isLatestPhase}\n          />\n          <WDArrowContainer\n            phase={phase}\n            orders={orders}\n            units={units}\n            maps={maps}\n            territories={territories}\n          />\n          {isLatestPhase && <WDBuildContainer />}\n          {isLatestPhase && <WDFlyoutContainer units={units} />}\n        </g>\n      </g>\n      <defs>\n        <pattern\n          id=\"capturable-land\"\n          patternUnits=\"userSpaceOnUse\"\n          width=\"1546\"\n          height=\"1384\"\n        >\n          <image\n            href={CapturableLandTexture}\n            x=\"0\"\n            y=\"0\"\n            width=\"1546\"\n            height=\"1384\"\n          />\n        </pattern>\n        <pattern\n          id=\"sea-texture\"\n          patternUnits=\"userSpaceOnUse\"\n          width=\"1546\"\n          height=\"1384\"\n        >\n          <image href={WaterTexture} x=\"0\" y=\"0\" width=\"1966\" height=\"1615\" />\n        </pattern>\n        {WDArrowMarkerDefs()}\n\n        <filter id=\"selectionGlow\" height=\"120%\" width=\"120%\" x=\"-10%\" y=\"-10%\">\n          <feMorphology\n            operator=\"dilate\"\n            radius=\"5\"\n            in=\"SourceAlpha\"\n            result=\"thickerSource\"\n          />\n          <feGaussianBlur\n            stdDeviation=\"8\"\n            in=\"thickerSource\"\n            result=\"blurredSource\"\n          />\n          <feFlood floodColor=\"rgb(100,200,255)\" result=\"glowColor\" />\n          <feComposite\n            in=\"glowColor\"\n            in2=\"blurredSource\"\n            operator=\"in\"\n            result=\"selectionGlowGlow\"\n          />\n        </filter>\n        <filter id=\"choiceGlow\" height=\"120%\" width=\"120%\" x=\"-10%\" y=\"-10%\">\n          <feMorphology\n            operator=\"dilate\"\n            radius=\"1\"\n            in=\"SourceAlpha\"\n            result=\"thickerSource\"\n          />\n          <feGaussianBlur\n            stdDeviation=\"6\"\n            in=\"thickerSource\"\n            result=\"blurredSource\"\n          />\n          <feFlood floodColor=\"rgb(255,255,255)\" result=\"glowColor\" />\n          <feComposite\n            in=\"glowColor\"\n            in2=\"blurredSource\"\n            operator=\"in\"\n            result=\"choicesGlowGlow\"\n          />\n        </filter>\n      </defs>\n    </svg>\n  ),\n);\n\nexport default React.memo(WDMap);\n","import * as React from \"react\";\nimport * as d3 from \"d3\";\nimport Device from \"../../enums/Device\";\nimport getInitialViewTranslation from \"../../utils/map/getInitialViewTranslation\";\nimport Scale from \"../../types/Scale\";\nimport WDMap from \"../map/WDMap\";\nimport useViewport from \"../../hooks/useViewport\";\nimport getDevice from \"../../utils/getDevice\";\nimport { useAppDispatch, useAppSelector } from \"../../state/hooks\";\nimport {\n  gameApiSliceActions,\n  gameOrdersMeta,\n  gameOverview,\n  gameStatus,\n  gameData,\n  gameMaps,\n  gameViewedPhase,\n  gameLegalOrders,\n} from \"../../state/game/game-api-slice\";\nimport {\n  Unit,\n  getUnitsLive,\n  getUnitsHistorical,\n} from \"../../utils/map/getUnits\";\nimport { IOrderData, IOrderDataHistorical } from \"../../models/Interfaces\";\nimport provincesMapData from \"../../data/map/ProvincesMapData\";\n\nconst Scales: Scale = {\n  DESKTOP: [0.45, 3],\n  MOBILE_LG: [0.32, 1.6],\n  MOBILE_LG_LANDSCAPE: [0.3, 1.6],\n  MOBILE: [0.32, 1.6],\n  MOBILE_LANDSCAPE: [0.27, 1.6],\n  TABLET: [0.6275, 3],\n  TABLET_LANDSCAPE: [0.6, 3],\n};\n\nconst getInitialScaleForDevice = (device: Device): number[] => {\n  return Scales[device];\n};\n\nconst mapOriginalWidth = 6010;\nconst mapOriginalHeight = 3005;\n\n// TODO big spaghetti to unify webdip's historical representation\n// with webdip's live representation\n// and with ordersMeta.\n// into one single set of data about orders and units that we can\n// pass down so that everything else below us renders functionally\n// based on that.\nconst WDMapController: React.FC = function (): React.ReactElement {\n  const svgElement = React.useRef<SVGSVGElement>(null);\n  const [viewport] = useViewport();\n  const dispatch = useAppDispatch();\n  const ordersMeta = useAppSelector(gameOrdersMeta);\n  const device = getDevice(viewport);\n  const [scaleMin, scaleMax] = getInitialScaleForDevice(device);\n\n  // FIXME: it's not ideal for us to be fetching the whole world from store here\n  // This is hard to untangle though because the representation of the data in the\n  // store is relatively bad. You have to depend on a lot of stuff in order to\n  // draw useful things right now.\n  const viewedPhaseState = useAppSelector(gameViewedPhase);\n  const overview = useAppSelector(gameOverview);\n  const status = useAppSelector(gameStatus);\n  const data = useAppSelector(gameData);\n  const maps = useAppSelector(gameMaps);\n\n  const updateForPhase = () => {\n    if (\n      viewedPhaseState.viewedPhaseIdx >= status.phases.length - 1 &&\n      status.status === \"Playing\" && // only live viewing if game not over\n      overview.user // only do live viewing if non-spectating\n    ) {\n      // Convert from our internal order representation to webdip's\n      // historical representation of orders so that we draw\n      // our internal orders and webdip's historical orders\n      // exactly the same way.\n\n      const ordersHistorical: IOrderDataHistorical[] = [];\n      const currentOrdersById: { [key: number]: IOrderData } = {};\n      if (data.data.currentOrders) {\n        data.data.currentOrders.forEach((orderData) => {\n          currentOrdersById[orderData.id] = orderData;\n        });\n      }\n      Object.entries(ordersMeta).forEach(([orderID, orderMeta]) => {\n        // FIXME ordersMeta can accumulate garbage over multiple phases.\n        // Is there anywhere else where we iterate over it and therefore iterate\n        // over garbage orders?\n        if (!currentOrdersById[orderID]) {\n          return;\n        }\n        let fromTerrID = 0;\n        let toTerrID = 0;\n        let terrID = 0;\n        let type: string | null = \"\";\n        let unitType = \"\";\n        let viaConvoy;\n\n        let { originalOrder } = orderMeta;\n        if (!originalOrder) {\n          originalOrder = currentOrdersById[orderID];\n        }\n        if (originalOrder) {\n          if (originalOrder.fromTerrID) {\n            fromTerrID = Number(originalOrder.fromTerrID);\n          }\n          if (originalOrder.toTerrID) {\n            toTerrID = Number(originalOrder.toTerrID);\n          }\n          type = originalOrder.type;\n\n          if (type && type.startsWith(\"Build \")) {\n            if (originalOrder.toTerrID) {\n              terrID = Number(originalOrder.toTerrID);\n            }\n            [, unitType] = type.split(\" \");\n          } else if (originalOrder.unitID) {\n            const terrIDString = maps.unitToTerrID[originalOrder.unitID];\n            if (terrIDString) {\n              terrID = Number(terrIDString);\n            }\n            unitType = data.data.units[originalOrder.unitID].type;\n          }\n\n          if (originalOrder.viaConvoy === \"Yes\") {\n            viaConvoy = \"Yes\";\n          } else {\n            viaConvoy = \"No\";\n          }\n        }\n        if (orderMeta.update) {\n          if (orderMeta.update.fromTerrID !== undefined) {\n            fromTerrID = Number(orderMeta.update.fromTerrID);\n          }\n          toTerrID = Number(orderMeta.update.toTerrID);\n          type = orderMeta.update.type;\n          if (orderMeta.update.viaConvoy === \"Yes\") {\n            viaConvoy = \"Yes\";\n          } else {\n            viaConvoy = \"No\";\n          }\n        }\n\n        // !terrID is safe because webdip doesn't seem to use terrID 0.\n        if (!type || !unitType || !terrID) {\n          return;\n        }\n\n        const orderHistorical: IOrderDataHistorical = {\n          countryID: status.countryID,\n          dislodged: \"No\",\n          fromTerrID,\n          phase: overview.phase,\n          success: \"Yes\",\n          terrID,\n          toTerrID,\n          turn: overview.turn,\n          type,\n          unitType,\n          viaConvoy,\n        };\n        ordersHistorical.push(orderHistorical);\n      });\n      // console.log(\"Ordershistorical\");\n      // console.log(currentOrdersById);\n      // console.log(state.game.ordersMeta);\n      // console.log(ordersHistorical);\n\n      // Also depends on status, so this is updated both here and when GameStatus is fulfilled.\n      const prevPhaseOrders =\n        status.phases.length > 1\n          ? status.phases[status.phases.length - 2].orders\n          : [];\n      const units: Unit[] = getUnitsLive(\n        data.data.territories,\n        data.data.territoryStatuses,\n        data.data.units,\n        overview.members,\n        prevPhaseOrders,\n        ordersMeta,\n        data.data.currentOrders ? data.data.currentOrders : [],\n        overview.user,\n        overview.phase,\n        maps,\n      );\n\n      const centersByProvince: { [key: string]: { ownerCountryID: string } } =\n        {};\n      data.data.territoryStatuses.forEach((provinceStatus) => {\n        const province = maps.terrIDToProvince[provinceStatus.id];\n        const ownerCountryID = provinceStatus.ownerCountryID || \"0\";\n        centersByProvince[province] = { ownerCountryID };\n      });\n\n      return {\n        phase: overview.phase,\n        units,\n        orders: ordersHistorical,\n        centersByProvince,\n        isLatestPhase: true,\n      };\n    }\n\n    const phaseHistorical = status.phases[viewedPhaseState.viewedPhaseIdx];\n    const unitsHistorical = phaseHistorical.units;\n    const prevPhaseOrders =\n      viewedPhaseState.viewedPhaseIdx > 0\n        ? status.phases[viewedPhaseState.viewedPhaseIdx - 1].orders\n        : [];\n    const unitsLive = getUnitsHistorical(\n      data.data.territories,\n      unitsHistorical,\n      overview.members,\n      prevPhaseOrders,\n      phaseHistorical.orders,\n      maps,\n    );\n    const centersByProvince: {\n      [key: string]: { ownerCountryID: string };\n    } = {};\n    phaseHistorical.centers.forEach((iCenter) => {\n      centersByProvince[maps.terrIDToProvince[iCenter.terrID]] = {\n        ownerCountryID: iCenter.countryID.toString(),\n      };\n    });\n    return {\n      phase: phaseHistorical.phase as string,\n      units: unitsLive,\n      orders: phaseHistorical.orders,\n      centersByProvince,\n      isLatestPhase: false,\n    };\n  };\n  const { phase, units, orders, centersByProvince, isLatestPhase } =\n    updateForPhase();\n  const { territories } = data.data;\n\n  // const legalOrders = useAppSelector(gameLegalOrders);\n  // console.log({ legalOrders });\n\n  React.useLayoutEffect(() => {\n    if (svgElement.current) {\n      const fullMap = d3.select(svgElement.current);\n      const contained = fullMap.select(\"#container\");\n      const containedRect = contained.node().getBBox();\n      const gameBoardAreaRect = fullMap\n        .select(\"#playableProvinces\")\n        .node()\n        .getBBox();\n\n      const { scale, x, y } = getInitialViewTranslation(\n        containedRect,\n        gameBoardAreaRect,\n        scaleMin,\n        viewport,\n      );\n\n      const zoom = ({ transform }) => {\n        contained.attr(\"transform\", transform);\n      };\n\n      const d3Zoom = d3\n        .zoom()\n        .translateExtent([\n          [0, 0],\n          [mapOriginalWidth, mapOriginalHeight],\n        ])\n        .scaleExtent([scale, scaleMax])\n        .clickDistance(3)\n        .on(\"zoom\", zoom);\n\n      fullMap\n        .on(\"wheel\", (e) => e.preventDefault())\n        .call(d3Zoom)\n        .call(d3Zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale))\n        .on(\"dblclick.zoom\", null);\n    }\n  }, [svgElement, viewport]);\n\n  React.useEffect(() => {\n    setTimeout(() => {\n      dispatch(gameApiSliceActions.updateOrdersMeta(ordersMeta));\n    }, 500);\n  }, []);\n\n  React.useEffect(() => {\n    const keydownHandler = (e) => {\n      const keyCode = e.which || e.keyCode;\n      const ESCAPE = 27;\n      // console.log(\"KEYCODE\");\n      // console.log(keyCode);\n      if (keyCode === ESCAPE) {\n        e.preventDefault();\n        // console.log(\"DISPATCH RESET ORDER\");\n        dispatch(gameApiSliceActions.resetOrder());\n      }\n    };\n    // console.log(\"ADDING HANLDER\");\n    window.addEventListener(\"keydown\", keydownHandler);\n    return () => window.removeEventListener(\"keydown\", keydownHandler);\n  });\n\n  return (\n    <div\n      style={{\n        width: viewport.width,\n        height: viewport.height,\n      }}\n    >\n      <WDMap\n        ref={svgElement}\n        units={units}\n        phase={phase}\n        orders={orders}\n        maps={maps}\n        territories={territories}\n        centersByProvince={centersByProvince}\n        isLatestPhase={isLatestPhase}\n      />\n    </div>\n  );\n};\n\nexport default WDMapController;\n","import { Viewport, BBox } from \"../../interfaces\";\nimport Translation from \"../../types/Translation\";\n\nexport default function getInitialViewTranslation(\n  containedRect: BBox,\n  gameBoardRect: BBox,\n  scale: number,\n  viewport: Viewport,\n): Translation {\n  let newScale = scale;\n  const containedHeight = containedRect.height * scale;\n\n  if (containedHeight < viewport.height) {\n    newScale = scale + (1 - containedHeight / viewport.height);\n  }\n\n  const translatedGameBoardAreaHeight = gameBoardRect.height * newScale;\n  const translatedGameBoardAreaY = gameBoardRect.y * newScale;\n\n  const translatedGameBoardAreaWidth = gameBoardRect.width * newScale;\n  const translatedGameBoardAreaX = gameBoardRect.x * newScale;\n\n  const nonPlayableHorizontalArea = Math.abs(\n    viewport.width - translatedGameBoardAreaWidth,\n  );\n  const horizontalPadding = Math.abs(nonPlayableHorizontalArea / 2);\n\n  const nonPlayableVerticalArea = Math.abs(\n    viewport.height - translatedGameBoardAreaHeight,\n  );\n  const verticalPadding = Math.abs(nonPlayableVerticalArea / 2);\n  const verticalBottomPadding =\n    (containedRect.y +\n      containedRect.height -\n      (gameBoardRect.y + gameBoardRect.height)) *\n    newScale;\n\n  let x: number;\n  let y: number;\n\n  if (viewport.height >= translatedGameBoardAreaHeight) {\n    y = -translatedGameBoardAreaY + verticalPadding;\n    if (verticalPadding > verticalBottomPadding) {\n      y += verticalPadding - verticalBottomPadding;\n    }\n  } else {\n    y = -translatedGameBoardAreaY - verticalPadding;\n  }\n\n  if (viewport.width >= translatedGameBoardAreaWidth) {\n    x = -translatedGameBoardAreaX + horizontalPadding;\n  } else {\n    x = -translatedGameBoardAreaX - horizontalPadding;\n  }\n\n  return {\n    scale: newScale,\n    x,\n    y,\n  };\n}\n"],"names":["className","height","width","fill","style","opacity","province","x","y","theme","useTheme","id","viewBox","xmlns","d","stroke","palette","primary","main","WDLabel","text","fontWeight","fontSize","userSelect","defaultProps","undefined","UnitDrawMode","provinceMapData","ownerCountryID","playerCountryID","highlightSelection","dispatch","useAppDispatch","useAppSelector","gameOverview","members","user","territoryFill","territoryFillOpacity","ownerCountry","find","m","countryID","Number","country","type","playerCountry","onClick","e","evt","gameApiSliceActions","clickProvince","texture","path","strokeOpacity","strokeWidth","fillOpacity","centerPos","labels","map","i","name","txt","abbr","children","overflow","ArrowType","units","highlightChoice","unitFCs","unitFCsDislodging","filter","unit","mappedTerritory","forEach","unitState","drawMode","NONE","UIState","HOLD","BUILD","DISLODGING","DISLODGED","DISBANDED","wdUnit","WDUnit","meta","iconState","unitSlotName","unitSlots","arrowReceiver","unitName","centersByProvince","phase","isLatestPhase","gameDataResponse","gameData","maps","gameMaps","provinceStatusByProvID","data","territoryStatuses","provinceStatus","terrIDToProvince","curOrder","gameOrder","legalOrders","gameLegalOrders","overview","provincesToHighlight","provincesToChoose","inProgress","viaConvoy","unitToTerrID","unitID","legalViasByUnitID","via","TerritoryMap","dest","legalMoveDestsByUnitID","territory","fromTerrID","legalSupportsByUnitID","support","Object","keys","legalConvoysByUnitID","legalRetreatDestsByUnitID","push","member","supplyCenterNo","unitNo","possibleBuildDests","provincesToHighlightSet","Set","provincesToChooseSet","unplayableProvinces","values","provincesMapData","playable","playableProvincesData","Province","playableProvinces","has","playableProvinceOverlays","BuildUnit","WDArrowMarkerColors","arrowType","entries","webDiplomacyTheme","arrowColor","config","ArrowColor","markerWidth","markerHeight","refX","refY","orient","points","markerUnits","Army","Fleet","availableOrder","clickCallback","canBuild","toTerrID","svgX","unitSlotsBySlotName","svgY","rw","buildButtons","iconStyle","groupStyle","cursor","cx","iconX","r","cy","WDArmyIcon","shift","length","WDFleetIcon","rx","ry","order","userMember","state","game","Box","terrIDToTerritory","orderID","terrIDToBuildOn","BuildUnitMap","terrIDToProvinceID","saved","update","countryMap","position","clickHandler","unitX","unitY","shiftX","shiftY","Error","rh","textAnchor","alignmentBaseline","fontFamily","u","mTerr","unitToTerritory","orderType","hasAnyLegalConvoysByUnitID","getTargetXYWH","identifier","arrowX1","arrowY1","toTerritoryName","Territory","toTerritoryData","UNIT_WIDTH","UNIT_HEIGHT","getArrowX1Y1X2Y2","sourceType","sourceIdentifier","receiverType","receiverIdentifier","sx1","sy1","sourceWidth","sourceHeight","rx2","ry2","receiverWidth","unitH","unitW","x1","x2","y1","y2","xDiff","yDiff","Math","abs","theta","atan2","x1New","cos","y1New","sin","x2New","y2New","arrowDispatchReceiveCoordinates","drawArrowFunctional","strokeDasharray","offsetArrowSourcePixels","dx","dy","sqrt","dxunit","dyunit","dyunitRotated","markerEnd","getProvIDNumberOfTerrIDNumber","terrID","territories","coastParentID","orders","arrows","ordersByProvID","fromTerr","toTerr","success","accumulateMoveOrderArrows","supporterProvIDToSupporteeProvID","provID","supporteeProvID","supporterProvID","supporterTerr","supporteeOrder","supporteeTerr","accumulateSupportHoldOrderArrows","isCoordinated","toString","accumulateSupportMoveOrderArrows","convoyerTerr","convoyeeTerr","convoyeeOrder","accumulateConvoyOrderArrows","accumulateRetreatArrows","movedFromTerrID","accumulateDislodgerArrows","terr","w","h","accumulateBuildCircles","WDMap","React","ref","patternUnits","href","CapturableLandTexture","WaterTexture","WDArrowMarkerDefs","operator","radius","in","result","stdDeviation","floodColor","in2","Scales","DESKTOP","MOBILE_LG","MOBILE_LG_LANDSCAPE","MOBILE","MOBILE_LANDSCAPE","TABLET","TABLET_LANDSCAPE","svgElement","useViewport","viewport","ordersMeta","gameOrdersMeta","device","getInitialScaleForDevice","getDevice","scaleMin","scaleMax","viewedPhaseState","gameViewedPhase","status","gameStatus","viewedPhaseIdx","phases","ordersHistorical","currentOrdersById","currentOrders","orderData","orderMeta","unitType","originalOrder","startsWith","split","terrIDString","orderHistorical","dislodged","turn","prevPhaseOrders","currentUser","unitsToDraw","territoryStatusesByProvID","fromEntries","territoryStatus","unitCountByProvID","successfulPrevMoves","prevOrder","ordersMetaByTerrID","currentOrder","excessUnitsBeyondSCs","isDestroyPhase","allDestroysAssigned","getAvailableOrder","webdipNameToTerritory","memberCountry","unitProvID","isRetreat","index","iUnit","getUnitsLive","phaseHistorical","unitsHistorical","unitsLive","curPhaseOrders","unitCountByTerrID","curPhaseOrdersByTerrID","retreating","getUnitsHistorical","centers","iCenter","updateForPhase","current","fullMap","d3","contained","select","containedRect","gameBoardRect","scale","newScale","containedHeight","translatedGameBoardAreaHeight","translatedGameBoardAreaY","translatedGameBoardAreaWidth","translatedGameBoardAreaX","nonPlayableHorizontalArea","horizontalPadding","nonPlayableVerticalArea","verticalPadding","verticalBottomPadding","getInitialViewTranslation","node","getBBox","d3Zoom","translateExtent","scaleExtent","clickDistance","on","transform","attr","preventDefault","call","setTimeout","keydownHandler","which","keyCode","window","addEventListener","removeEventListener"],"sourceRoot":""}